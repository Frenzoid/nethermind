// SPDX-FileCopyrightText: 2023 Demerzel Solutions Limited
// SPDX-License-Identifier: LGPL-3.0-only

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nethermind.Serialization.Ssz.Generator;

namespace SourceGenerator
{
    public class EncoderGenerator
    {
        static readonly string _prefix = """
            // <auto-generated/>
            #nullable enable
            #pragma warning disable CS0108 // hides inherited member
            #pragma warning disable CS0162 // Unreachable code
            #pragma warning disable CS0164 // This label has not been referenced
            #pragma warning disable CS0219 // Variable assigned but never used
            #pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
            #pragma warning disable CS8601 // Possible null reference assignment
            #pragma warning disable CS8602
            #pragma warning disable CS8604 // Possible null reference argument for parameter
            #pragma warning disable CS8619
            #pragma warning disable CS8620
            #pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
            #pragma warning disable CS8765 // Nullability of type of parameter
            #pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
            #pragma warning disable CA1050 // Declare types in namespaces.

            using System;
            """;

        static Dictionary<TypeMetadata, string> _emitedTypeEncoder = new();
        static HashSet<TypeMetadata> _neededTypeEncoders = new();

        static bool IsPartial(TypeDeclarationSyntax typeDeclaration)
        {
            return typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        }

        static bool IsNested(TypeDeclarationSyntax typeDeclaration)
        {
            return typeDeclaration.Parent is TypeDeclarationSyntax;
        }

        public void EmitEncoderForType(SourceProductionContext context, Compilation compilation, TypeDeclarationSyntax syntax)
        {
            var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

            var typeSymbol = semanticModel.GetDeclaredSymbol(syntax);
            if (typeSymbol == null)
            {
                return;
            }

            if (!IsPartial(syntax))
            {
                throw new System.Exception($"Type {typeSymbol.Name} must be marked as partial!");
            }

            var typedata = new TypeMetadata(typeSymbol);
            var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_");

            var sb = new StringBuilder(_prefix);
            var ns = typedata.Symbol.ContainingNamespace;

            if (!ns.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {ns};");
            }

            typedata.GenerateCode(sb, context);

            var code = sb.ToString();
            context.AddSource($"{fullType}.ssz.g.cs", code);
        }
    }
}
